commaSep<x> { "" | x ( "," x)* }

ParamValue { Identifier ( "=" expression)? }
ParamList { commaSep<ParamValue>  }
FuncDef { functionKwd openParen ParamList closeParen !funbody expression }





| ControlExpr 

ifExpr { ifKwd newline* openParen newline* expression newline* closeParen newline* !if expression }

elseOption { expression !else newline* !else elseKwd newline* expression }

repeatExpr { repeatKwd newline* !repeat expression }

ControlExpr {
  ifExpr | repeatExpr | elseOption
}


ifKwd { "if" }
elseKwd { "else" }
repeatKwd { "repeat" }

 | Comment

  Comment { "#" ![\n]* }

==============


ifExpr { !ifelse ifKwd newline* openParen newline* expression newline* closeParen newline* !if expression }

elseOption { expression !else2 newline* !else elseKwd newline* expression }

repeatExpr { repeatKwd newline* !repeat expression }

ControlExpr {
  ifExpr | repeatExpr | elseOption
}


| Integer | Logical | Complex

    Logical,

    Complex,
    Integer,

     Logical { "TRUE" | "FALSE" }

     
  Integer { number "L" }

  Complex { number "i" }


  simpleName {
    ( identifierChar | "." ) ( ( identifierChar | "." | "_" ) ( identifierChar | @digit | "." | "_" )* )?
  }


  @precedence {

    Numeric,
    simpleName
  }


  identifierChar { @asciiLetter }

 
repeatKwd { kw<"repeat"> }

# 2/17/23

functionKwd[@export] { kw<"function"> }


repeatKwd { kw<"repeat"> }
whileKwd[@export] { kw<"while"> }
forKwd[@export] { kw<"for"> }
inKwd { kw<"in"> }

 openBrace[@export] { "{" }
  closeBrace[@export] { "}" }

ifExpr { ifKwd newline* openParen newline* expression newline* closeParen !if newline* expression ( ( ";" | ";"? newline+ ) elseKwd newline* !else expression )?  }

  

repeatExpr { repeatKwd newline* !repeat expression }
whileExpr { whileKwd newline* openParen newline* expression newline* closeParen newline* !while expression }
forExpr { forKwd newline* openParen newline* Identifier newline* inKwd newline* !in expression newline* closeParen newline* !for expression }

Character | 

 Identifier |

Identifier { 
  simpleName | backtickName   
}

  | repeatExpr | whileExpr | forExpr
  
  
  Block { openBrace newline* !block ( expression ( ";" | ";"? newline+ ) !exprterm )* ( expression? closeBrace ) }

  
   | Block




   simpleName {
    ( identifierChar | "." ) ( ( identifierChar | "." | "_" ) ( identifierChar | @digit | "." | "_" )* )?
  }


  backtickName { "`" ![\n]* "`" }

  Character {
    '"' ( ![\\\n"] | '\\' '"' )*  '"' |
    "'" ( ![\\\n'] | "\\" "'" )*  "'"
  }


  infix0 { "%%" }
  infix1 { "%" ![%] "%" }
  infix2 { "%" ![%] ![%] "%" }
  infix3 { "%" ![%] ![%] ![%]  "%" }
  infix4 { "%" ![%] ![%] ![%] ![%] "%" }
  infix5 { "%" ![%] ![%] ![%] ![%] ![%] "%" }
  infix6 { "%" ![%] ![%] ![%] ![%] ![%] ![%] "%" }
  infix7 { "%" ![%] ![%] ![%] ![%] ![%] ![%] ![%] "%" }
  infix8 { "%" ![%] ![%] ![%] ![%] ![%] ![%] ![%] ![%] "%" }
  infix9 { "%" ![%] ![%] ![%] ![%] ![%] ![%] ![%] ![%] ![%] "%" }


    infix0
    infix1,
    infix2,
    infix3,
    infix4,
    infix5,
    infix6,
    infix7,
    infix8,
    infix9,

    backtickName,

    Character,

    ,
    simpleName



    expression newline* !times ArithOp<"*"> newline* expression |
    expression newline* !plus ArithOp<"+"> newline* expression 


######################################################
| ControlExpr | IndexExpr |
    StdCall | FuncDef |


EmptyArg { ~emptyvalue }
ArgValue { ~emptyvalue ( Identifier "=" )? expression }
ArgList { 
  ( ArgValue | EmptyArg ) ( "," ( ArgValue | EmptyArg) )*  
}
StdCall { expression !funcall openParen ArgList closeParen }

IndexExpr {
  expression !index openBrack ArgList closeBrack |
  expression !index openDBrack ArgList closeDBrack
}

commaSep<x> { "" | x ( "," x)* }

ParamValue { Identifier ( "=" expression)? }
ParamList { commaSep<ParamValue>  }
FuncDef { functionKwd openParen ParamList closeParen !funbody expression }

ifExpr { ifKwd nlsok openParen nlsok expression  nlsok closeParen nlsok !if expression ( !else elseKwd nlsok expression)? } 

repeatExpr { repeatKwd nlsok !repeat expression }
whileExpr { whileKwd nlsok openParen nlsok expression nlsok closeParen nlsok !while expression }
forExpr { forKwd nlsok openParen nlsok Identifier nlsok inKwd nlsok !in expression nlsok ")" nlsok !for expression }

ControlExpr {
  ifExpr | repeatExpr | whileExpr | forExpr
}



ifExpr { ifKwd newline* openParen newline* expression ( () | newline+ ) closeParen newline* !if expression }

repeatExpr { repeatKwd newline* !repeat expression }
whileExpr { whileKwd newline* openParen nlsok expression ( () | newline+ ) closeParen newline* !while expression }

ControlExpr {
  ifExpr | repeatExpr | whileExpr
}




#########################################################
## from before
#########################################################

UnclosedParenExpr { 
  ~parencheck 
  openParen nlsok  
  ( semiTermExpr | !exprnl nlTermExpr | eofTermExpr | braceTermExpr | closeBrace | eof ) 
}


UnaryExpr {
    !sign ArithOp< "+" | "-" > nlsok expression | 
    !not LogicOp< "!" > nlsok expression |
    !frmla GenOp< "~" > nlsok expression 
}

BinaryExpr { 
    expression !seq nlsok GenOp< ":" > nlsok expression |
    expression !times nlsok ArithOp< "*" | "/" > nlsok expression |
    expression !plus nlsok ArithOp< "+" | "-" > nlsok expression |
    expression !exp nlsok ArithOp< "^" > nlsok expression |
    expression !infix nlsok GenOp< infix > nlsok expression |
    expression !comp nlsok CompOp< "<" | ">" | ">=" | "<=" | "==" | "!=" > nlsok expression |
    expression !and nlsok LogicOp< "&" | "&&" > nlsok expression |
    expression !or nlsok LogicOp< "|" | "||" > nlsok expression |
    expression !lassign nlsok AssignOp< "<-" | "<<-" > nlsok expression |
    expression !rassign nlsok AssignOp< "->" | "->>" > nlsok expression |
    expression !frmla nlsok GenOp< "~" > nlsok expression | 
    expression !compon nlsok GenOp< "$" | "@" > nlsok ( Identifier | Character ) |
    Identifier !member nlsok GenOp< "::" | ":::" > nlsok Identifier
}

BinaryExpr { 
    expression !seq newline* GenOp< ":" > nlsok expression |
    expression !times newline* ArithOp< "*" | "/" > nlsok expression |
    expression !plus newline* ArithOp< "+" | "-" > nlsok expression |
    expression !exp newline* ArithOp< "^" > nlsok expression |
    expression !infix newline* GenOp< infix > nlsok expression |
    expression !comp newline* CompOp< "<" | ">" | ">=" | "<=" | "==" | "!=" > nlsok expression |
    expression !and newline* LogicOp< "&" | "&&" > nlsok expression |
    expression !or newline* LogicOp< "|" | "||" > nlsok expression |
    expression !lassign newline* AssignOp< "<-" | "<<-" > nlsok expression |
    expression !rassign newline* AssignOp< "->" | "->>" > nlsok expression |
    expression !frmla newline* GenOp< "~" > nlsok expression | 
    expression !compon newline* GenOp< "$" | "@" > nlsok ( Identifier | Character ) |
    Identifier !member newline* GenOp< "::" | ":::" > nlsok Identifier
}



EmptyArg { ~emptyvalue }
ArgValue { ~emptyvalue ( Identifier "=" )? expression }
ArgList { 
  ( ArgValue | EmptyArg ) ( "," ( ArgValue | EmptyArg) )*  
}
StdCall { expression !funcall openParen ArgList closeParen }

IndexExpr {
  expression !index openBrack ArgList closeBrack |
  expression !index openDBrack ArgList closeDBrack
}

commaSep<x> { "" | x ( "," x)* }

ParamValue { Identifier ( "=" expression)? }
ParamList { commaSep<ParamValue>  }
FuncDef { functionKwd openParen ParamList closeParen !funbody expression }

ifExpr { ifKwd nlsok openParen nlsok expression  nlsok closeParen nlsok !if expression ( !else elseKwd nlsok expression)? } 

repeatExpr { repeatKwd nlsok !repeat expression }
whileExpr { whileKwd nlsok openParen nlsok expression nlsok closeParen nlsok !while expression }
whileExpr { whileKwd nlsok ParenExpr nlsok !while expression }
forExpr { forKwd nlsok openParen nlsok Identifier nlsok inKwd nlsok !in expression nlsok ")" nlsok !for expression }

ControlExpr {
  ifExpr | repeatExpr | whileExpr | forExpr
}


call {
    UnaryExpr | BinaryExpr| ControlExpr | IndexExpr |
    StdCall | FuncDef |
    Block | ParenExpr
}